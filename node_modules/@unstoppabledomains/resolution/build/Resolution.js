"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var bn_js_1 = __importDefault(require("bn.js"));
var Ens_1 = __importDefault(require("./Ens"));
var Zns_1 = __importDefault(require("./Zns"));
var Cns_1 = __importDefault(require("./Cns"));
var UdApi_1 = __importDefault(require("./UdApi"));
var publicTypes_1 = require("./types/publicTypes");
var resolutionError_1 = __importStar(require("./errors/resolutionError"));
var DnsUtils_1 = __importDefault(require("./utils/DnsUtils"));
var utils_1 = require("./utils");
var Eip1993Factories_1 = require("./utils/Eip1993Factories");
var configurationError_1 = __importDefault(require("./errors/configurationError"));
var configurationError_2 = require("./errors/configurationError");
/**
 * Blockchain domain Resolution library - Resolution.
 * @example
 * ```
 * import Resolution from '@unstoppabledomains/resolution';
 *
 * let resolution = new Resolution({ blockchain: {
 *        ens: {
 *           url: "https://mainnet.infura.io/v3/12351245223",
 *           network: "mainnet"
 *        }
 *      }
 *   });
 *
 * let domain = "brad.zil";
 * resolution.addr(domain, "eth").then(addr => console.log(addr));;
 * ```
 */
var Resolution = /** @class */ (function () {
    function Resolution(_a) {
        var _b;
        var _c = (_a === void 0 ? {} : _a).sourceConfig, sourceConfig = _c === void 0 ? undefined : _c;
        var cns = (isApi(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.cns) ? new UdApi_1.default(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.cns.url) : new Cns_1.default(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.cns));
        var ens = (isApi(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.ens) ? new UdApi_1.default(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.ens.url) : new Ens_1.default(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.ens));
        var zns = (isApi(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.zns) ? new UdApi_1.default(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.zns.url) : new Zns_1.default(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.zns));
        this.serviceMap = (_b = {},
            _b[publicTypes_1.NamingServiceName.CNS] = cns,
            _b[publicTypes_1.NamingServiceName.ENS] = ens,
            _b[publicTypes_1.NamingServiceName.ZNS] = zns,
            _b);
    }
    /**
     * AutoConfigure the blockchain network between different testnets for ENS and CNS
     * We make a "net_version" JSON RPC call to the blockchain either via url or with the help of given provider.
     * @param sourceConfig - configuration object for ens and cns
     * @returns configured Resolution object
     */
    Resolution.autoNetwork = function (sourceConfig) {
        return __awaiter(this, void 0, void 0, function () {
            var resolution, _a, _b, _c, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        resolution = new this();
                        if (!sourceConfig.cns && !sourceConfig.ens) {
                            throw new configurationError_1.default(configurationError_2.ConfigurationErrorCode.UnsupportedNetwork);
                        }
                        if (!sourceConfig.cns) return [3 /*break*/, 2];
                        _a = resolution.serviceMap;
                        _b = publicTypes_1.NamingServiceName.CNS;
                        return [4 /*yield*/, Cns_1.default.autoNetwork(sourceConfig.cns)];
                    case 1:
                        _a[_b] = _e.sent();
                        _e.label = 2;
                    case 2:
                        if (!sourceConfig.ens) return [3 /*break*/, 4];
                        _c = resolution.serviceMap;
                        _d = publicTypes_1.NamingServiceName.ENS;
                        return [4 /*yield*/, Ens_1.default.autoNetwork(sourceConfig.ens)];
                    case 3:
                        _c[_d] = _e.sent();
                        _e.label = 4;
                    case 4: return [2 /*return*/, resolution];
                }
            });
        });
    };
    /**
     * Creates a resolution with configured infura id for ens and cns
     * @param infura - infura project id
     * @param networks - an optional object that describes what network to use when connecting ENS or CNS default is mainnet
     */
    Resolution.infura = function (infura, networks) {
        var _a, _b, _c, _d;
        return new this({
            sourceConfig: {
                ens: { url: utils_1.signedInfuraLink(infura, (_a = networks === null || networks === void 0 ? void 0 : networks.ens) === null || _a === void 0 ? void 0 : _a.network), network: ((_b = networks === null || networks === void 0 ? void 0 : networks.ens) === null || _b === void 0 ? void 0 : _b.network) || "mainnet" },
                cns: { url: utils_1.signedInfuraLink(infura, (_c = networks === null || networks === void 0 ? void 0 : networks.ens) === null || _c === void 0 ? void 0 : _c.network), network: ((_d = networks === null || networks === void 0 ? void 0 : networks.cns) === null || _d === void 0 ? void 0 : _d.network) || "mainnet" },
            },
        });
    };
    /**
     * Creates a resolution instance with configured provider
     * @param provider - any provider compatible with EIP-1193
     * @param networks - an optional object that describes what network to use when connecting ENS or CNS default is mainnet
     * @see https://eips.ethereum.org/EIPS/eip-1193
     */
    Resolution.fromEip1193Provider = function (provider, networks) {
        var _a, _b;
        return new this({
            sourceConfig: {
                ens: { provider: provider, network: ((_a = networks === null || networks === void 0 ? void 0 : networks.ens) === null || _a === void 0 ? void 0 : _a.network) || "mainnet" },
                cns: { provider: provider, network: ((_b = networks === null || networks === void 0 ? void 0 : networks.cns) === null || _b === void 0 ? void 0 : _b.network) || "mainnet" },
            },
        });
    };
    /**
     * Create a resolution instance from web3 0.x version provider
     * @param provider - an 0.x version provider from web3 ( must implement sendAsync(payload, callback) )
     * @param networks - Ethereum network configuration
     * @see https://github.com/ethereum/web3.js/blob/0.20.7/lib/web3/httpprovider.js#L116
     */
    Resolution.fromWeb3Version0Provider = function (provider, networks) {
        return this.fromEip1193Provider(Eip1993Factories_1.Eip1993Factories.fromWeb3Version0Provider(provider), networks);
    };
    /**
     * Create a resolution instance from web3 1.x version provider
     * @param provider - an 1.x version provider from web3 ( must implement send(payload, callback) )
     * @param networks - an optional object that describes what network to use when connecting ENS or CNS default is mainnet
     * @see https://github.com/ethereum/web3.js/blob/1.x/packages/web3-core-helpers/types/index.d.ts#L165
     * @see https://github.com/ethereum/web3.js/blob/1.x/packages/web3-providers-http/src/index.js#L95
     */
    Resolution.fromWeb3Version1Provider = function (provider, networks) {
        return this.fromEip1193Provider(Eip1993Factories_1.Eip1993Factories.fromWeb3Version1Provider(provider), networks);
    };
    /**
     * Creates instance of resolution from provider that implements Ethers Provider#call interface.
     * This wrapper support only `eth_call` method for now, which is enough for all the current Resolution functionality
     * @param provider - provider object
     * @param networks - an optional object that describes what network to use when connecting ENS or CNS default is mainnet
     * @see https://github.com/ethers-io/ethers.js/blob/v4-legacy/providers/abstract-provider.d.ts#L91
     * @see https://github.com/ethers-io/ethers.js/blob/v5.0.4/packages/abstract-provider/src.ts/index.ts#L224
     * @see https://docs.ethers.io/ethers.js/v5-beta/api-providers.html#jsonrpcprovider-inherits-from-provider
     * @see https://github.com/ethers-io/ethers.js/blob/master/packages/providers/src.ts/json-rpc-provider.ts
     */
    Resolution.fromEthersProvider = function (provider, networks) {
        return this.fromEip1193Provider(Eip1993Factories_1.Eip1993Factories.fromEthersProvider(provider), networks);
    };
    /**
     * Resolves given domain name to a specific currency address if exists
     * @async
     * @param domain - domain name to be resolved
     * @param ticker - currency ticker like BTC, ETH, ZIL
     * @throws [[ResolutionError]] if address is not found
     * @returns A promise that resolves in an address
     */
    Resolution.prototype.addr = function (domain, ticker) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.record(domain, "crypto." + ticker.toUpperCase() + ".address")];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Read multi-chain currency address if exists
     * @async
     * @param domain - domain name to be resolved
     * @param ticker - currency ticker (USDT, FTM, etc.)
     * @param chain - chain version, usually means blockchain ( ERC20, BEP2, OMNI, etc. )
     * @throws [[ResolutionError]] if address is not found
     * @returns A promise that resolves in an adress
    */
    Resolution.prototype.multiChainAddr = function (domain, ticker, chain) {
        return __awaiter(this, void 0, void 0, function () {
            var method, recordKey;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        domain = this.prepareDomain(domain);
                        method = this.getNamingMethodOrThrow(domain);
                        if (method.serviceName() === publicTypes_1.NamingServiceName.ENS) {
                            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedMethod, { methodName: publicTypes_1.NamingServiceName.ENS, domain: domain });
                        }
                        recordKey = "crypto." + ticker.toUpperCase() + ".version." + chain.toUpperCase() + ".address";
                        return [4 /*yield*/, method.record(domain, recordKey)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Resolves given domain name to a verified twitter handle
     * @async
     * @param domain - domain name to be resolved
     * @throws [[ResolutionError]] if twitter is not found
     * @returns A promise that resolves in a verified twitter handle
     */
    Resolution.prototype.twitter = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var method;
            return __generator(this, function (_a) {
                domain = this.prepareDomain(domain);
                method = this.getNamingMethodOrThrow(domain);
                return [2 /*return*/, method.twitter(domain)];
            });
        });
    };
    /**
     * Resolve a chat id from the domain record
     * @param domain - domain name to be resolved
     * @throws [[ResolutionError]]
     * @returns A promise that resolves in chatId
     */
    Resolution.prototype.chatId = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.record(domain, 'gundb.username.value')];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Resolve a gundb public key from the domain record
     * @param domain - domain name to be resolved
     * @throws [[ResolutionError]]
     * @returns a promise that resolves in gundb public key
     */
    Resolution.prototype.chatPk = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.record(domain, 'gundb.public_key.value')];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Resolves the IPFS hash configured for domain records on ZNS
     * @param domain - domain name
     * @throws [[ResolutionError]]
     */
    Resolution.prototype.ipfsHash = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        domain = this.prepareDomain(domain);
                        return [4 /*yield*/, this.getPreferableNewRecord(domain, 'dweb.ipfs.hash', 'ipfs.html.value')];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Resolves the httpUrl attached to domain
     * @param domain - domain name
     */
    Resolution.prototype.httpUrl = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        domain = this.prepareDomain(domain);
                        return [4 /*yield*/, this.getPreferableNewRecord(domain, 'browser.redirect_url', 'ipfs.redirect_domain.value')];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Resolves the ipfs email field from whois configurations
     * @param domain - domain name
     * @throws [[ResolutionError]]
     * @returns A Promise that resolves in an email address configured for this domain whois
     */
    Resolution.prototype.email = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.record(domain, 'whois.email.value')];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * @returns the resolver address for a specific domain
     * @param domain - domain to look for
     */
    Resolution.prototype.resolver = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var resolver;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        domain = this.prepareDomain(domain);
                        return [4 /*yield*/, this.getNamingMethodOrThrow(domain).resolver(domain)];
                    case 1:
                        resolver = _a.sent();
                        if (!resolver) {
                            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnspecifiedResolver, {
                                domain: domain,
                            });
                        }
                        return [2 /*return*/, resolver];
                }
            });
        });
    };
    /**
     * @param domain - domain name
     * @returns An owner address of the domain
     */
    Resolution.prototype.owner = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var method;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        domain = this.prepareDomain(domain);
                        method = this.getNamingMethodOrThrow(domain);
                        return [4 /*yield*/, method.owner(domain)];
                    case 1: return [2 /*return*/, (_a.sent()) || null];
                }
            });
        });
    };
    /**
     * @param domain - domain name
     * @param recordKey - a name of a record to be resolved
     * @returns A record value promise for a given record name
     */
    Resolution.prototype.record = function (domain, recordKey) {
        return __awaiter(this, void 0, void 0, function () {
            var method;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        domain = this.prepareDomain(domain);
                        method = this.getNamingMethodOrThrow(domain);
                        return [4 /*yield*/, method.record(domain, recordKey)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * @param domain domain name
     * @param keys Array of record keys to be resolved
     * @returns A Promise with key-value mapping of domain records
     */
    Resolution.prototype.records = function (domain, keys) {
        return __awaiter(this, void 0, void 0, function () {
            var method;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        domain = this.prepareDomain(domain);
                        method = this.getNamingMethodOrThrow(domain);
                        return [4 /*yield*/, method.records(domain, keys)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * This method is only for ens at the moment. Reverse the ens address to a ens registered domain name
     * @async
     * @param address - address you wish to reverse
     * @param currencyTicker - currency ticker like BTC, ETH, ZIL
     * @returns Domain name attached to this address
     */
    Resolution.prototype.reverse = function (address, currencyTicker) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (this.serviceMap[publicTypes_1.NamingServiceName.ENS].reverse(address, currencyTicker))];
            });
        });
    };
    /**
     * @returns Produces a namehash from supported naming service in hex format with 0x prefix.
     * Corresponds to ERC721 token id in case of Ethereum based naming service like ENS or CNS.
     * @param domain domain name to be converted
     * @param options formatting options
     * @throws [[ResolutionError]] with UnsupportedDomain error code if domain extension is unknown
     */
    Resolution.prototype.namehash = function (domain, options) {
        if (options === void 0) { options = publicTypes_1.NamehashOptionsDefault; }
        domain = this.prepareDomain(domain);
        return this.formatNamehash(this.getNamingMethodOrThrow(domain).namehash(domain), options);
    };
    /**
     * @returns a namehash of a subdomain with name label
     * @param parent namehash of a parent domain
     * @param label subdomain name
     * @param namingService "ENS", "CNS" or "ZNS"
     * @param options formatting options
     */
    Resolution.prototype.childhash = function (parent, label, namingService, options) {
        if (options === void 0) { options = publicTypes_1.NamehashOptionsDefault; }
        var service = this.serviceMap[namingService];
        if (!service) {
            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedService, { namingService: namingService });
        }
        return this.formatNamehash(service.childhash(parent, label), options);
    };
    Resolution.prototype.formatNamehash = function (hash, options) {
        hash = hash.replace('0x', '');
        if (options.format === 'dec') {
            return new bn_js_1.default(hash, 'hex').toString(10);
        }
        else {
            return options.prefix ? '0x' + hash : hash;
        }
    };
    /**
     * Checks weather the domain name matches the hash
     * @param domain - domain name to check againt
     * @param hash - hash obtained from the blockchain
     */
    Resolution.prototype.isValidHash = function (domain, hash) {
        domain = this.prepareDomain(domain);
        return this.namehash(domain) === hash;
    };
    /**
     * Checks if the domain name is valid according to naming service rules
     * for valid domain names.
     * Example: ENS doesn't allow domains that start from '-' symbol.
     * @param domain - domain name to be checked
     */
    Resolution.prototype.isSupportedDomain = function (domain) {
        var _a;
        domain = this.prepareDomain(domain);
        return !!((_a = this.getNamingMethod(domain)) === null || _a === void 0 ? void 0 : _a.isSupportedDomain(domain));
    };
    /**
     * Returns the name of the service for a domain ENS | CNS | ZNS
     * @param domain - domain name to look for
     */
    Resolution.prototype.serviceName = function (domain) {
        domain = this.prepareDomain(domain);
        return this.getNamingMethodOrThrow(domain).serviceName();
    };
    /**
     * Returns all record keys of the domain.
     * This method is strongly unrecommended for production use due to lack of support for many ethereum service providers and low performance
     * Method is not supported by ENS
     * @param domain - domain name
     */
    Resolution.prototype.allRecords = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        domain = this.prepareDomain(domain);
                        return [4 /*yield*/, this.getNamingMethodOrThrow(domain).allRecords(domain)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Resolution.prototype.dns = function (domain, types) {
        return __awaiter(this, void 0, void 0, function () {
            var dnsUtils, method, dnsRecordKeys, blockchainData;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        dnsUtils = new DnsUtils_1.default();
                        domain = this.prepareDomain(domain);
                        method = this.getNamingMethodOrThrow(domain);
                        dnsRecordKeys = this.getDnsRecordKeys(types);
                        return [4 /*yield*/, method.records(domain, dnsRecordKeys)];
                    case 1:
                        blockchainData = _a.sent();
                        return [2 /*return*/, dnsUtils.toList(blockchainData)];
                }
            });
        });
    };
    Resolution.prototype.getDnsRecordKeys = function (types) {
        var records = ['dns.ttl'];
        types.forEach(function (type) {
            records.push("dns." + type);
            records.push("dns." + type + ".ttl");
        });
        return records;
    };
    Resolution.prototype.getPreferableNewRecord = function (domain, newRecord, oldRecord) {
        return __awaiter(this, void 0, void 0, function () {
            var records;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.records(domain, [
                            newRecord,
                            oldRecord,
                        ])];
                    case 1:
                        records = (_a.sent());
                        if (!records[newRecord] && !records[oldRecord]) {
                            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.RecordNotFound, {
                                recordName: newRecord,
                                domain: domain,
                            });
                        }
                        return [2 /*return*/, (records[newRecord] || records[oldRecord])];
                }
            });
        });
    };
    Resolution.prototype.getNamingMethod = function (domain) {
        return this.serviceMap[utils_1.findNamingServiceName(domain)];
    };
    Resolution.prototype.getNamingMethodOrThrow = function (domain) {
        var method = this.getNamingMethod(domain);
        if (!method) {
            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedDomain, {
                domain: domain,
            });
        }
        return method;
    };
    Resolution.prototype.prepareDomain = function (domain) {
        return domain ? domain.trim().toLowerCase() : '';
    };
    return Resolution;
}());
exports.Resolution = Resolution;
exports.default = Resolution;
function isApi(obj) {
    return obj && obj.api;
}
